import { useState } from 'react';
import { supabase } from '@/lib/supabase';

interface EmailVerificationResult {
  success: boolean;
  error?: any;
  user?: any;
}

export const useEmailVerification = () => {
  const [isLoading, setIsLoading] = useState(false);

  const sendVerificationEmail = async (email?: string): Promise<EmailVerificationResult> => {
    setIsLoading(true);
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        throw new Error('User not authenticated');
      }

      // Use provided email or current user email
      const targetEmail = email || user.email;
      
      if (!targetEmail) {
        throw new Error('No email address found');
      }

      console.log('üìß Sending verification email to:', targetEmail);
      console.log('üë§ User context:', { 
        id: user.id, 
        email: user.email, 
        email_confirmed_at: user.email_confirmed_at 
      });

      const redirectTo = `${window.location.origin}/verify-email`;
      console.log('üîç Magic link configuration:', {
        targetEmail,
        redirectTo,
        currentOrigin: window.location.origin,
        currentHref: window.location.href
      });

      // Use signInWithOtp with proper configuration for longer token lifetime
      const { data, error } = await supabase.auth.signInWithOtp({
        email: targetEmail,
        options: {
          emailRedirectTo: redirectTo,
          shouldCreateUser: true, // Allow creating user if needed
          captchaToken: null // Disable captcha for testing
        }
      });

      console.log('üìä Supabase signInWithOtp response:', { data, error });

      if (error) {
        console.error('‚ùå SignInWithOtp error:', {
          message: error.message,
          status: error.status,
          code: error.code
        });

        // Handle specific error types
        if (error.message.includes('rate limit') || 
            error.message.includes('too_many_requests') ||
            error.status === 429) {
          throw new Error('‡∏Ñ‡∏∏‡∏ì‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ö‡πà‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠ 3-5 ‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
        } else if (error.message.includes('not_found') || 
                   error.message.includes('user not found')) {
          throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÉ‡∏´‡∏°‡πà');
        } else if (error.status === 422) {
          throw new Error('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
        } else {
          throw new Error(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏î‡πâ'}`);
        }
      }

      console.log('‚úÖ Magic link request completed successfully');
      
      return { success: true };
    } catch (error: any) {
      console.error('‚ùå Send verification email error:', error);
      return { success: false, error };
    } finally {
      setIsLoading(false);
    }
  };

  const verifyEmailWithToken = async (token: string): Promise<EmailVerificationResult> => {
    setIsLoading(true);
    
    try {
      console.log('üîç Verifying email with token:', token);
      console.log('üîç Token length:', token?.length);

      // For magic links from signInWithOtp, we need to use verifyOtp with different parameters
      // Try different verification methods based on token format
      
      let verificationResult;
      
      // Method 1: Try as magic link token (most common for signInWithOtp)
      try {
        console.log('üß™ Attempting magic link verification...');
        verificationResult = await supabase.auth.verifyOtp({
          token_hash: token,
          type: 'magiclink' // For magic links generated by signInWithOtp
        });
        
        if (!verificationResult.error) {
          console.log('‚úÖ Magic link verification successful');
        }
      } catch (magicLinkError) {
        console.log('‚ö†Ô∏è Magic link verification failed:', magicLinkError);
      }
      
      // Method 2: Try as email confirmation token (fallback)
      if (!verificationResult || verificationResult.error) {
        console.log('üß™ Attempting email confirmation verification...');
        verificationResult = await supabase.auth.verifyOtp({
          token_hash: token,
          type: 'email' // For email confirmations
        });
        
        if (!verificationResult.error) {
          console.log('‚úÖ Email confirmation verification successful');
        }
      }
      
      // Method 3: Try as signup confirmation (another fallback)
      if (!verificationResult || verificationResult.error) {
        console.log('üß™ Attempting signup confirmation verification...');
        verificationResult = await supabase.auth.verifyOtp({
          token_hash: token,
          type: 'signup' // For signup confirmations
        });
        
        if (!verificationResult.error) {
          console.log('‚úÖ Signup confirmation verification successful');
        }
      }
      
      const { data, error } = verificationResult;
      
      if (error) {
        console.error('‚ùå All verification methods failed:', error);
        
        // Handle specific error types
        if (error.message.includes('expired')) {
          throw new Error('‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ç‡∏≠‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÉ‡∏´‡∏°‡πà');
        } else if (error.message.includes('invalid') || error.message.includes('not found')) {
          throw new Error('‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏à‡∏≤‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì');
        } else {
          throw new Error(`‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ${error.message}`);
        }
      }

      if (data.user) {
        console.log('‚úÖ Email verification successful:', {
          email: data.user.email,
          id: data.user.id,
          email_confirmed_at: data.user.email_confirmed_at
        });
        
        // Update profiles table
        const { error: updateError } = await supabase
          .from('profiles')
          .update({ 
            email_verified: true,
            email_verified_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('user_id', data.user.id);

        if (updateError) {
          console.error('‚ö†Ô∏è Profile update error:', updateError);
          // Don't fail the verification if profile update fails
        } else {
          console.log('‚úÖ Profile table updated - email_verified: true');
        }

        return { success: true, user: data.user };
      }
      
      throw new Error('No user data returned from verification');
    } catch (error: any) {
      console.error('‚ùå Email verification error:', error);
      return { success: false, error };
    } finally {
      setIsLoading(false);
    }
  };

  const checkEmailVerificationStatus = async (): Promise<{ isVerified: boolean; email?: string }> => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return { isVerified: false };
      }

      // Check from profiles table
      const { data: profile } = await supabase
        .from('profiles')
        .select('email_verified')
        .eq('user_id', user.id)
        .maybeSingle();

      return {
        isVerified: profile?.email_verified || false,
        email: user.email || undefined
      };
    } catch (error) {
      console.error('Error checking email verification status:', error);
      return { isVerified: false };
    }
  };

  return {
    sendVerificationEmail,
    verifyEmailWithToken,
    checkEmailVerificationStatus,
    isLoading
  };
};